<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Digital Level Indicator with Embedded Rust</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/theme/black.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/highlight/monokai.css">
    <style>
        .reveal h1, .reveal h2, .reveal h3 { text-transform: none; }
        .reveal pre { width: 100%; }
        .reveal pre code { max-height: 500px; padding: 20px; }
        .reveal .slides section { text-align: left; }
        .reveal .center { text-align: center; }
        .reveal ul, .reveal ol { margin-left: 0; padding-left: 1.2em; }
        .reveal .small { font-size: 0.7em; }
        .reveal .highlight { color: #e7ad52; font-weight: bold; }
        .reveal .success { color: #5cb85c; }
        .reveal .danger { color: #d9534f; }
        .reveal .comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .reveal .comparison > div { border: 1px solid #555; padding: 15px; }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <!-- SLIDE 1: Title -->
            <section class="center">
                <h1>Building a Digital Level Indicator</h1>
                <h3>with Embedded Rust</h3>
                <p style="margin-top: 60px;">A Case Study in Memory-Safe Bare-Metal Programming</p>
                <p class="small" style="margin-top: 40px;">Matthew Orris | HighQ.aero Interview</p>

                <aside class="notes">
                    <h4>Opening (30 seconds):</h4>
                    <p>Good morning/afternoon. I'm Matthew Orris, and today I'm going to share a project that demonstrates Rust's unique value proposition for embedded systems.</p>
                    <p>This is a real embedded project: a digital level indicator that uses an accelerometer to detect tilt and provides visual feedback through LEDs. What makes this interesting isn't just what it does, but HOW it was built—and the stark difference between the Rust and C++ implementations.</p>
                </aside>
            </section>

            <!-- SLIDE 2: The Project -->
            <section>
                <h2>The Project: Digital Level Indicator</h2>
                <ul>
                    <li><strong>Hardware:</strong> STM32F407VG Discovery Board</li>
                    <li><strong>Sensor:</strong> LIS3DSH 3-axis accelerometer (SPI)</li>
                    <li><strong>Output:</strong> 4 LEDs (North/East/South/West) via PWM</li>
                    <li><strong>Function:</strong> Dim the LED on the side that's tilted up</li>
                </ul>
                <div style="margin-top: 40px; padding: 20px; background: #1a1a1a; border-left: 4px solid #5cb85c;">
                    <p class="success" style="margin: 0;"><strong>Rust Implementation:</strong> Worked on first compile</p>
                </div>
                <div style="margin-top: 20px; padding: 20px; background: #1a1a1a; border-left: 4px solid #d9534f;">
                    <p class="danger" style="margin: 0;"><strong>C++ Port:</strong> Required significant SPI debugging</p>
                </div>

                <aside class="notes">
                    <h4>The Setup (1.5 minutes):</h4>
                    <p><strong>Hardware:</strong> STM32F407VG is an ARM Cortex-M4F with hardware floating-point (FPU), running at 84 MHz. This is the Discovery board—you probably have these on your desks.</p>
                    <p><strong>Sensor:</strong> LIS3DSH is a MEMS accelerometer that communicates over SPI Mode 3. It provides ±2g acceleration data as 16-bit signed integers.</p>
                    <p><strong>The Task:</strong> Read the accelerometer at 100 Hz, filter the signal, calculate tilt angles, and smoothly adjust LED brightness. When you tip the board, the LED on the HIGH side dims.</p>
                    <p><strong>THE KEY POINT:</strong> The Rust version worked immediately—no runtime debugging. The C++ version had multiple issues: wrong SPI protocol, stack overflow, data not updating. This isn't because I'm better at Rust than C++. It's because Rust's type system and borrow checker caught entire categories of bugs at compile time.</p>
                </aside>
            </section>

            <!-- SLIDE 3: Why Rust for Embedded? -->
            <section>
                <h2>Why Rust for Embedded Systems?</h2>
                <ul>
                    <li><strong>Memory safety without runtime cost</strong>
                        <ul class="small">
                            <li>No null pointers, buffer overflows, use-after-free</li>
                            <li>All caught at <span class="highlight">compile time</span>, zero runtime overhead</li>
                        </ul>
                    </li>
                    <li><strong>Type-safe hardware access</strong>
                        <ul class="small">
                            <li>Can't write to wrong register</li>
                            <li>Can't use peripheral before initialization</li>
                        </ul>
                    </li>
                    <li><strong>Zero-cost abstractions</strong>
                        <ul class="small">
                            <li>Traits and generics compile to same assembly as C</li>
                        </ul>
                    </li>
                    <li><strong>Fearless refactoring</strong>
                        <ul class="small">
                            <li>Compiler catches breaking changes across entire codebase</li>
                        </ul>
                    </li>
                </ul>

                <aside class="notes">
                    <h4>The Value Proposition (2.5 minutes):</h4>
                    <p><strong>Memory Safety:</strong> You know the pain of debugging a HardFault at 3am because of a null pointer or buffer overflow. Rust's ownership system makes these impossible. The borrow checker enforces that only one mutable reference OR multiple immutable references can exist at a time. No data races, no iterator invalidation.</p>
                    <p><strong>Type-Safe Hardware:</strong> In C, register addresses are just numbers. In Rust, peripherals are types. You can't accidentally write to the wrong register. You can't use SPI before calling init() because the type system tracks initialization state.</p>
                    <p><strong>Zero-Cost:</strong> This is crucial—Rust's abstractions compile away. A generic function over a trait becomes a direct function call, no vtables. The generated assembly is identical to hand-written C.</p>
                    <p><strong>Refactoring:</strong> When you change an API in a 100k line codebase, the compiler finds EVERY call site that needs updating. You're not hunting through grep results hoping you found them all.</p>
                    <p><strong>Key point for your team:</strong> You already write careful C++ with code reviews and static analysis. Rust moves those checks into the compiler, catching bugs before they reach review.</p>
                </aside>
            </section>

            <!-- SLIDE 4: The no_std Ecosystem -->
            <section>
                <h2>The <code>no_std</code> Embedded Rust Ecosystem</h2>
                <ul>
                    <li><strong>What is <code>no_std</code>?</strong>
                        <ul class="small">
                            <li>No operating system, no heap, no standard library</li>
                            <li>Only core library: integers, floats, Option, Result, traits</li>
                            <li>All allocations on the stack (known at compile time)</li>
                        </ul>
                    </li>
                    <li><strong>The HAL Stack:</strong>
                        <ul class="small">
                            <li><code>cortex-m</code>: ARM core peripherals (NVIC, SysTick, etc.)</li>
                            <li><code>stm32f4xx-hal</code>: STM32-specific GPIO, SPI, timers, etc.</li>
                            <li><code>embedded-hal</code>: Portable traits (like Linux kernel abstractions)</li>
                            <li><code>lis3dsh</code>: Accelerometer driver (works with any HAL)</li>
                        </ul>
                    </li>
                    <li><strong>Modern Tooling:</strong>
                        <ul class="small">
                            <li><code>cargo</code>: Build system, package manager (like npm/pip but better)</li>
                            <li><code>probe-rs</code>: Flash and debug without OpenOCD</li>
                            <li><code>defmt</code>: Efficient logging (formatting done on host, not target)</li>
                        </ul>
                    </li>
                </ul>

                <aside class="notes">
                    <h4>The Ecosystem (3 minutes):</h4>
                    <p><strong>no_std explained:</strong> In regular Rust, you have std::vec::Vec, std::string::String, heap allocation, threads, file I/O. In embedded, we use #![no_std] which removes all of that. You only get core—the language fundamentals. Everything must be stack-allocated or static.</p>
                    <p><strong>The HAL layers are like Linux kernel abstractions:</strong></p>
                    <ul>
                        <li><strong>PAC (Peripheral Access Crate):</strong> Auto-generated from SVD files. Raw register access, type-safe but low-level.</li>
                        <li><strong>HAL (Hardware Abstraction Layer):</strong> High-level API. "Give me SPI with these pins at this speed." Hides register details.</li>
                        <li><strong>embedded-hal traits:</strong> Generic interfaces. A driver written against embedded-hal::spi::Transfer works on ANY microcontroller with a HAL that implements that trait. Write once, run on STM32, nRF52, ESP32, etc.</li>
                    </ul>
                    <p><strong>Tooling advantage:</strong> cargo is phenomenal. One command to build, one command to test, built-in documentation. probe-rs replaces OpenOCD—it just works. defmt is genius: instead of sprintf() on the target (slow, uses RAM), it sends format indices to your computer which does the string formatting. Fast logging with zero impact.</p>
                    <p><strong>For your team:</strong> The tooling is a huge selling point. New engineers are productive in days, not weeks.</p>
                </aside>
            </section>

            <!-- SLIDE 5: Architecture Overview -->
            <section>
                <h2>Clean Architecture: Three Layers</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 40px;">
                    <div style="border: 2px solid #e7ad52; padding: 20px; text-align: center;">
                        <h4>Hardware Layer</h4>
                        <p class="small"><code>Accelerometer</code></p>
                        <p class="small">SPI communication</p>
                        <p class="small">Raw sensor data</p>
                    </div>
                    <div style="border: 2px solid #e7ad52; padding: 20px; text-align: center;">
                        <h4>Algorithm Layer</h4>
                        <p class="small"><code>LevelDetector</code></p>
                        <p class="small">EMA filtering</p>
                        <p class="small">Tilt calculation</p>
                    </div>
                    <div style="border: 2px solid #e7ad52; padding: 20px; text-align: center;">
                        <h4>Control Layer</h4>
                        <p class="small"><code>LedController</code></p>
                        <p class="small">PWM management</p>
                        <p class="small">Brightness control</p>
                    </div>
                </div>
                <div style="margin-top: 40px;">
                    <p class="small"><strong>Main loop:</strong> Read → Filter → Calculate → Update (100 Hz)</p>
                </div>

                <aside class="notes">
                    <h4>Architecture (1 minute overview):</h4>
                    <p>The code is organized into three clean modules, each with a single responsibility:</p>
                    <p><strong>1. Accelerometer:</strong> Abstracts the LIS3DSH sensor. Exposes simple API: read_xy_g() returns (x, y) in g-force units. Internally handles SPI protocol, chip select, register addressing, byte ordering.</p>
                    <p><strong>2. LevelDetector:</strong> Pure algorithm. Takes accelerometer readings, applies EMA filter to smooth vibrations, calculates tilt angles using atan2, maps angles to brightness values with deadband.</p>
                    <p><strong>3. LedController:</strong> Owns the PWM peripherals. Converts 0-255 brightness to duty cycle. Prevents you from mixing up which channel controls which LED.</p>
                    <p><strong>Why this matters:</strong> Each module can be tested independently. If the accelerometer changes, only one file changes. If the LED hardware changes, only one file changes. This is good engineering in any language, but Rust's module system and traits make it natural.</p>
                    <p><strong>Next slides:</strong> We'll dive deep into each layer.</p>
                </aside>
            </section>

            <!-- SLIDE 6: Main Entry Point -->
            <section>
                <h2>Main Entry Point: <code>no_std</code> Setup</h2>
                <pre><code class="rust" data-trim data-line-numbers="1-2|4-5|7-8|9-11|13-18|20-23|27-29">
#![no_std]        // Don't link standard library
#![no_main]       // We provide our own entry point

use panic_probe as _;  // Panic handler for debugging
use cortex_m_rt::entry;

#[entry]
fn main() -> ! {  // Never returns (! = "never" type)
    // Take ownership of device peripherals (can only happen once)
    let dp = pac::Peripherals::take().unwrap();
    let cp = cortex_m::Peripherals::take().unwrap();

    // Configure clocks: 8 MHz HSE -> PLL -> 84 MHz sysclk
    let mut rcc = dp.RCC.freeze(
        Config::hse(8.MHz())
            .sysclk(84.MHz())
            .pclk1(42.MHz())
    );

    // Configure GPIO ports (must pass &mut rcc for clock enables)
    let gpioa = dp.GPIOA.split(&mut rcc);
    let gpiod = dp.GPIOD.split(&mut rcc);
    let gpioe = dp.GPIOE.split(&mut rcc);

    // ... peripheral initialization ...

    loop {
        // Main loop at 100 Hz
    }
}
                </code></pre>

                <aside class="notes">
                    <h4>Main Entry Deep-Dive (2 minutes):</h4>
                    <p><strong>#![no_std] and #![no_main]:</strong> These attributes tell the compiler we're in a bare-metal environment. No standard library, no main() provided by the runtime. We control everything.</p>
                    <p><strong>#[entry] macro:</strong> From cortex-m-rt crate. This generates the vector table, initializes RAM, calls our function. It's doing the work of crt0.S in C.</p>
                    <p><strong>fn main() -> ! (never type):</strong> The ! means this function never returns. Makes sense—we're the only code running on the MCU. We loop forever or reset.</p>
                    <p><strong>Peripherals::take():</strong> This is brilliant. Each peripheral (SPI1, TIM4, GPIOA) is a singleton. take() returns Option—Some on first call, None after. This means you CAN'T accidentally create two mutable references to the same hardware. The type system prevents hardware aliasing bugs.</p>
                    <p><strong>Clock configuration:</strong> We're using an 8 MHz external crystal (HSE), running it through the PLL to get 84 MHz system clock. pclk1 is the APB1 peripheral clock (42 MHz). These are builder patterns—very ergonomic.</p>
                    <p><strong>GPIO split():</strong> This "splits" GPIOA into individual pins. Once split, you can't access GPIOA as a whole anymore. Each pin is now an independent owned value. This prevents you from configuring PA5 as both an output and SPI_SCK at the same time—the compiler won't let you.</p>
                </aside>
            </section>

            <!-- SLIDE 7: Accelerometer Module -->
            <section>
                <h2>Hardware Layer: <code>Accelerometer</code></h2>
                <pre><code class="rust" data-trim data-line-numbers="1-8|10-16|18-26">
pub struct Accelerometer&lt;SPI, CS&gt;
where
    SPI: Transfer&lt;u8&gt;,      // Any type that implements SPI transfer
    CS: OutputPin,          // Any type that can control chip select
{
    driver: Lis3dsh&lt;Lis3dshSpi&lt;SPI, CS&gt;&gt;,
}

impl&lt;SPI, CS&gt; Accelerometer&lt;SPI, CS&gt;
where SPI: Transfer&lt;u8&gt;, CS: OutputPin
{
    pub fn new(spi: SPI, cs: CS, delay: &mut impl DelayMs&lt;u8&gt;)
        -> Result&lt;Self, SPI::Error&gt;
    {
        let mut driver = Lis3dsh::new_spi(spi, cs);
        driver.init(delay)?;  // Initialize sensor (soft reset, config)
        Ok(Self { driver })
    }

    pub fn read_xy_g(&mut self) -> Result&lt;(f32, f32), SPI::Error&gt; {
        let [x, y, _z] = self.driver.read_data()?;

        // Convert raw i16 to g-force (±2g range)
        const LSB_PER_G: f32 = 16_384.0;
        Ok((x as f32 / LSB_PER_G, y as f32 / LSB_PER_G))
    }
}
                </code></pre>

                <aside class="notes">
                    <h4>Accelerometer Deep-Dive (2.5 minutes):</h4>
                    <p><strong>Generic struct:</strong> This struct is generic over SPI and CS types. It doesn't care if SPI is stm32f4::Spi or some other MCU's SPI—it only requires that the type implements the Transfer&lt;u8&gt; trait from embedded-hal. This is how Rust achieves portability without runtime cost.</p>
                    <p><strong>Traits as constraints:</strong> Transfer&lt;u8&gt; is a trait with one method: fn transfer(buf: &mut [u8]). Any type implementing this can be used here. OutputPin is similar: high(), low(). These traits are the contract between hardware-agnostic drivers and hardware-specific HALs.</p>
                    <p><strong>Ownership of peripherals:</strong> When you call new(), you GIVE the SPI and CS to this struct. You can't use them elsewhere anymore. The accelerometer now OWNS that hardware. This prevents you from trying to talk to multiple SPI devices simultaneously without proper management.</p>
                    <p><strong>Result type:</strong> Rust doesn't have exceptions. Functions that can fail return Result&lt;T, E&gt;. The ? operator propagates errors up the call stack. If init() fails (sensor not responding), we return early with the error.</p>
                    <p><strong>The lis3dsh crate:</strong> I'm using an existing driver from crates.io. It handles all the SPI protocol details: two-transfer reads, register addresses, byte ordering. This is where the C++ version went wrong—trying to implement the protocol manually.</p>
                    <p><strong>LSB_PER_G conversion:</strong> The sensor returns 16-bit signed integers in ±2g range. 16384 LSB = 1g. This is fixed-point math. We convert to float for easier angle calculations.</p>
                </aside>
            </section>

            <!-- SLIDE 8: LevelDetector Algorithm -->
            <section>
                <h2>Algorithm Layer: <code>LevelDetector</code></h2>
                <pre><code class="rust" data-trim data-line-numbers="1-7|9-16|18-30">
pub struct LevelDetector {
    filtered_x: f32,  // EMA-filtered X acceleration
    filtered_y: f32,  // EMA-filtered Y acceleration
    alpha: f32,       // EMA smoothing factor (0.15)
    tilt_threshold: f32,  // Max tilt before LED fully dims (15°)
}

pub fn update(&mut self, accel_x: f32, accel_y: f32) -> LedBrightness {
    // Apply Exponential Moving Average filter
    self.filtered_x = self.alpha * accel_x
                    + (1.0 - self.alpha) * self.filtered_x;
    self.filtered_y = self.alpha * accel_y
                    + (1.0 - self.alpha) * self.filtered_y;

    // Calculate tilt angles in degrees
    let tilt_x = self.calculate_tilt(self.filtered_x, 1.0);
    let tilt_y = self.calculate_tilt(self.filtered_y, 1.0);

    LedBrightness {
        north: self.angle_to_brightness(tilt_x),
        south: self.angle_to_brightness(-tilt_x),
        east: self.angle_to_brightness(-tilt_y),
        west: self.angle_to_brightness(tilt_y),
    }
}

fn calculate_tilt(&self, axis_reading: f32, gravity: f32) -> f32 {
    let angle_rad = atan2f(axis_reading, gravity);  // libm (no_std)
    angle_rad * (180.0 / core::f32::consts::PI)    // Convert to degrees
}
                </code></pre>

                <aside class="notes">
                    <h4>Algorithm Deep-Dive (2.5 minutes):</h4>
                    <p><strong>No heap allocation:</strong> This struct is 16 bytes (4 floats). It lives on the stack. No malloc, no memory fragmentation.</p>
                    <p><strong>EMA Filter (Exponential Moving Average):</strong> This is a simple but effective low-pass filter. Alpha=0.15 means each new reading contributes 15%, and the old value contributes 85%. This smooths out vibrations and noise without requiring a buffer of old samples. It's computationally cheap (one multiply-add per axis) and has no memory overhead.</p>
                    <p><strong>Why filtering matters:</strong> Raw accelerometer data is NOISY. If you directly control LEDs from raw readings, they'll flicker constantly. The EMA gives us smooth, stable output.</p>
                    <p><strong>Tilt calculation:</strong> We use atan2 to convert acceleration to angle. When the board is level, Z-axis reads 1g (gravity), X and Y read ~0g. As you tilt, gravity's projection onto X and Y increases. atan2(x_accel, z_accel) gives you the tilt angle.</p>
                    <p><strong>libm crate:</strong> In no_std, we don't have std::f32::atan2. The libm crate provides pure-Rust implementations of math functions. The compiler can inline and optimize these aggressively.</p>
                    <p><strong>Coordinate system:</strong> Notice the sign inversions. If tilt_x is positive (USB side tipping up), the NORTH LED (which is on the USB side) should dim and the SOUTH LED should stay bright. Hence: south = brightness(-tilt_x).</p>
                    <p><strong>Pattern matching would work here too:</strong> We could return a struct and pattern match on it. Rust gives you options.</p>
                </aside>
            </section>

            <!-- SLIDE 9: Brightness Mapping -->
            <section>
                <h2>Brightness Mapping with Deadband</h2>
                <pre><code class="rust" data-trim data-line-numbers="1-15">
fn angle_to_brightness(&self, angle: f32) -> u8 {
    // Deadband: within ±3° is considered level (full brightness)
    // This prevents flickering when the board is nearly level
    if angle <= 3.0 {
        return 255;  // Full brightness
    }

    if angle >= self.tilt_threshold {  // 15°
        return 0;  // LED off
    }

    // Linear fade from 3° to 15°
    let brightness = 255.0 * (1.0 - (angle - 3.0)
                                   / (self.tilt_threshold - 3.0));
    brightness as u8
}
                </code></pre>
                <div style="margin-top: 30px; padding: 20px; background: #1a1a1a;">
                    <p class="small"><strong>Deadband prevents LED flutter:</strong> Small vibrations near level won't cause visible changes.</p>
                    <p class="small"><strong>Linear fade:</strong> Simple, predictable brightness response.</p>
                </div>

                <aside class="notes">
                    <h4>Brightness Mapping (1.5 minutes):</h4>
                    <p><strong>Deadband concept:</strong> When the board is nearly level (within ±3°), we just set brightness to 255 (full). This prevents the LEDs from flickering due to tiny accelerometer noise or hand tremor. Deadbands are essential in control systems.</p>
                    <p><strong>Why 3° deadband?</strong> Testing showed this was the sweet spot. Smaller and you get flicker. Larger and the response feels sluggish.</p>
                    <p><strong>Linear mapping:</strong> From 3° to 15°, we fade linearly. At 3°, brightness=255. At 15°, brightness=0. The formula: brightness = 255 × (1 - (angle-3)/(15-3)) is just a linear interpolation.</p>
                    <p><strong>as u8 cast:</strong> Rust requires explicit type conversions. f32 doesn't automatically become u8. This prevents accidental truncation bugs. The as keyword is an explicit "I know what I'm doing" cast.</p>
                    <p><strong>Alternative approaches:</strong> You could use a cubic ease-out for more natural motion, or adaptive deadband based on vibration amplitude. For this project, simple linear was sufficient.</p>
                </aside>
            </section>

            <!-- SLIDE 10: LED Controller -->
            <section>
                <h2>Control Layer: <code>LedController</code></h2>
                <pre><code class="rust" data-trim data-line-numbers="1-9|11-22">
pub struct LedController {
    ch1_west: PwmChannel&lt;TIM4, 0&gt;,   // Type-safe channel index
    ch2_north: PwmChannel&lt;TIM4, 1&gt;,
    ch3_east: PwmChannel&lt;TIM4, 2&gt;,
    ch4_south: PwmChannel&lt;TIM4, 3&gt;,
    max_duty: u16,
}

pub fn set_brightness(&mut self, west: u8, north: u8,
                      east: u8, south: u8) {
    // Scale 0-255 brightness to 0-max_duty PWM duty cycle
    let scale = |brightness: u8| -> u16 {
        ((brightness as u32 * self.max_duty as u32) / 255) as u16
    };

    self.ch1_west.set_duty(scale(west));
    self.ch2_north.set_duty(scale(north));
    self.ch3_east.set_duty(scale(east));
    self.ch4_south.set_duty(scale(south));
}
                </code></pre>

                <aside class="notes">
                    <h4>LED Controller Deep-Dive (2 minutes):</h4>
                    <p><strong>Type-safe PWM channels:</strong> Look at the channel types: PwmChannel&lt;TIM4, 0&gt;, PwmChannel&lt;TIM4, 1&gt;, etc. The channel index is part of the TYPE. You cannot accidentally pass ch2 where ch1 is expected—the compiler won't let you. This is const generics in action.</p>
                    <p><strong>Ownership of timers:</strong> When we create this struct, we GIVE it ownership of the PWM channels. Nothing else can use TIM4 anymore. This prevents conflicts where two parts of your code try to control the same timer.</p>
                    <p><strong>max_duty:</strong> PWM timers have a period register. max_duty is the value that corresponds to 100% duty cycle. On STM32 with 16-bit timers at 1 kHz, this might be 84,000 (84 MHz / 1 kHz). We store this and scale our 0-255 brightness to 0-max_duty.</p>
                    <p><strong>Closure for scaling:</strong> The 'let scale = |brightness| { ... }' is a closure (anonymous function). We're using it as a helper to avoid repeating the scaling math four times. The compiler will inline this—zero overhead.</p>
                    <p><strong>Integer math:</strong> We upcast to u32 for the multiply to avoid overflow (255 × 84000 exceeds u16), then divide, then downcast to u16. Rust's explicit casting forces you to think about this.</p>
                    <p><strong>API design:</strong> Notice we take four separate brightness values, not an array. This makes it IMPOSSIBLE to accidentally swap north and south. The type signature is documentation.</p>
                </aside>
            </section>

            <!-- SLIDE 11: The SPI Debugging Story -->
            <section>
                <h2>The SPI Debugging Story: Rust vs C++</h2>
                <div class="comparison">
                    <div>
                        <h4 class="success">Rust: (Mostly) Worked First Try</h4>
                        <ul class="small">
                            <li>Used <code>lis3dsh</code> crate (correct protocol)</li>
                            <li>Type system prevented pin assignment errors</li>
                            <li>Ownership prevented simultaneous SPI access</li>
                            <li>Initialization order enforced by types</li>
                            <li><strong>Zero runtime debugging</strong></li>
                        </ul>
                    </div>
                    <div>
                        <h4 class="danger">C++: Significant Debugging</h4>
                        <ul class="small">
                            <li>Wrong protocol: single transaction with multi-byte bit</li>
                            <li>Data froze—sensor wanted TWO transfers</li>
                            <li>Stack overflow from printf in tight loop</li>
                            <li>No type safety on register addresses</li>
                            <li><strong>Hours of debugging with debugger</strong></li>
                        </ul>
                    </div>
                </div>
                <div style="margin-top: 30px; padding: 20px; background: #1a1a1a; border-left: 4px solid #e7ad52;">
                    <p class="small"><strong>Root Cause:</strong> The LIS3DSH requires TWO SPI transfers for multi-byte reads (send command, then receive data). The C++ version tried ONE transfer with the multi-byte bit (0x40) set, which doesn't work. The Rust driver crate encodes the correct protocol, preventing this mistake.</p>
                </div>

                <aside class="notes">
                    <h4>The Debugging Story (3 minutes):</h4>
                    <p><strong>This is your differentiator.</strong> This is why Rust matters.</p>
                    <p><strong>Rust side:</strong> I wrote the code, compiled it, flashed it, and it WORKED. The LEDs responded to tilt immediately. No debugger, no logic analyzer, no printf debugging. Why? Because:</p>
                    <ul>
                        <li>The lis3dsh crate ALREADY implements the correct SPI protocol. I didn't have to read the 80-page datasheet.</li>
                        <li>The type system caught all the "dumb mistakes": wrong pin, forgot to enable clock, used peripheral before init.</li>
                        <li>The borrow checker prevented me from accessing SPI while the accelerometer owned it.</li>
                    </ul>
                    <p><strong>C++ side:</strong> The port was straightforward for most of it—clock config, GPIO, PWM. But the SPI accelerometer had multiple bugs:</p>
                    <ul>
                        <li><strong>Protocol bug:</strong> I tried HAL_SPI_TransmitReceive with the multi-byte bit (0x40) set, like 0xE8. The sensor returned data, but it never CHANGED. Frozen values. Turns out, the LIS3DSH requires TWO separate calls: HAL_SPI_Transmit(cmd), then HAL_SPI_Receive(data). The multi-byte bit breaks auto-increment.</li>
                        <li><strong>How we found it:</strong> Examined the Rust lis3dsh crate source code. It does TWO separate transfer() calls. That was the hint.</li>
                        <li><strong>Stack overflow:</strong> Used printf with floats in a tight loop. 1 KB stack was too small. Increased to 8 KB.</li>
                    </ul>
                    <p><strong>Why the difference?</strong> Rust guides you toward using proven libraries. C++ left us implementing low-level details where mistakes are easy.</p>
                    <p><strong>Key takeaway:</strong> Rust doesn't eliminate bugs, but it eliminates CATEGORIES of bugs. Memory bugs, type bugs, concurrency bugs—all caught at compile time.</p>
                </aside>
            </section>

            <!-- SLIDE 12: Rust Embedded Concepts -->
            <section>
                <h2>Advanced Rust Embedded Concepts</h2>
                <ul>
                    <li><strong>Ownership in Embedded</strong>
                        <ul class="small">
                            <li>No malloc/free—all allocations on stack or static</li>
                            <li>Compiler tracks ownership: one owner, lifetime ends → drop</li>
                            <li>Prevents use-after-free, double-free impossible</li>
                        </ul>
                    </li>
                    <li><strong>Traits for Hardware Abstraction</strong>
                        <ul class="small">
                            <li><code>embedded-hal</code> traits = portable interfaces</li>
                            <li>Write driver once, works on any MCU</li>
                            <li>Zero runtime cost (monomorphization)</li>
                        </ul>
                    </li>
                    <li><strong>Type State Pattern</strong>
                        <ul class="small">
                            <li>Encode peripheral state in the type system</li>
                            <li>Can't read SPI without configuring pins first</li>
                            <li>Compiler enforces initialization order</li>
                        </ul>
                    </li>
                    <li><strong>Const Generics</strong>
                        <ul class="small">
                            <li><code>PwmChannel&lt;TIM4, 0&gt;</code> vs <code>PwmChannel&lt;TIM4, 1&gt;</code></li>
                            <li>Channel index in the type, not runtime value</li>
                            <li>Prevents mixing up channels at compile time</li>
                        </ul>
                    </li>
                </ul>

                <aside class="notes">
                    <h4>Advanced Concepts (3 minutes):</h4>
                    <p><strong>Ownership:</strong> Every value has exactly one owner. When the owner goes out of scope, the value is "dropped" (destructor runs). You can borrow (&T) or mutably borrow (&mut T), but the borrow checker enforces: either one &mut T OR many &T, never both. This makes data races impossible at compile time.</p>
                    <p><strong>In embedded:</strong> No heap means ownership is even simpler. Everything lives in 'static or on the stack. The compiler proves at compile time that you're not leaking resources or accessing freed memory.</p>
                    <p><strong>Traits for HAL:</strong> The embedded-hal crate defines traits like spi::Transfer, digital::OutputPin, delay::DelayMs. Any HAL implementing these traits is compatible with any driver using them. This is like C++ templates, but with better error messages and zero runtime cost.</p>
                    <p><strong>Type State Pattern:</strong> This is a game-changer. Imagine a GPIO pin has three states: Unconfigured, Input, Output. In C, you just have a pointer. In Rust, you have three different TYPES: Pin&lt;Unconfigured&gt;, Pin&lt;Input&gt;, Pin&lt;Output&gt;. The into_push_pull_output() method consumes Pin&lt;Unconfigured&gt; and returns Pin&lt;Output&gt;. Now the API that requires an output pin can ONLY accept Pin&lt;Output&gt;—the compiler enforces this.</p>
                    <p><strong>Const Generics:</strong> You can have generic parameters that are VALUES, not types. PwmChannel&lt;TIM4, 0&gt; vs PwmChannel&lt;TIM4, 1&gt; are DIFFERENT types. You can't pass one where the other is expected. This catches wiring mistakes at compile time.</p>
                    <p><strong>For your team:</strong> These aren't academic features. They catch real bugs that would be runtime failures in C++.</p>
                </aside>
            </section>

            <!-- SLIDE 13: Results and Lessons -->
            <section>
                <h2>Results and Lessons Learned</h2>
                <ul>
                    <li><strong>Working Device:</strong> Smooth, responsive tilt detection with stable LED feedback</li>
                    <li><strong>Code Quality:</strong> Type-safe, well-documented, modular architecture</li>
                    <li><strong>Performance:</strong> 100 Hz update rate, minimal CPU usage</li>
                    <li><strong>Binary Size:</strong> Optimized with LTO and size optimization (<code>opt-level = "s"</code>)</li>
                </ul>
                <div style="margin-top: 30px;">
                    <h4>Key Lessons:</h4>
                    <ul class="small">
                        <li><strong>Read driver source code:</strong> The <code>lis3dsh</code> crate taught me the correct SPI protocol</li>
                        <li><strong>Filtering is essential:</strong> Raw sensor data is too noisy for control</li>
                        <li><strong>Deadbands prevent flicker:</strong> Small threshold around level state</li>
                        <li><strong>Rust's safety != slower development:</strong> Fewer bugs → faster overall</li>
                        <li><strong>Type system is documentation:</strong> Function signatures explain usage</li>
                    </ul>
                </div>

                <aside class="notes">
                    <h4>Results (2 minutes):</h4>
                    <p><strong>The device works great:</strong> LEDs smoothly fade as you tilt. No flicker, no lag. The EMA filter gives it a nice "damped" feel.</p>
                    <p><strong>Code quality:</strong> Because the type system forces you to be explicit, the code is self-documenting. If you see &mut self, you know it mutates state. If you see Result&lt;T, E&gt;, you know it can fail.</p>
                    <p><strong>Performance:</strong> 100 Hz is plenty for this application. The FPU on Cortex-M4F makes the trig fast. We're not even close to taxing the CPU.</p>
                    <p><strong>Binary size:</strong> Rust generates compact code with opt-level="s" and LTO. It's comparable to optimized C++. The zero-cost abstraction promise is real.</p>
                    <p><strong>Lessons:</strong></p>
                    <ul>
                        <li>Using existing crates is a superpower. Don't reinvent protocols.</li>
                        <li>Signal processing matters. Raw sensors are noisy.</li>
                        <li>Rust's compile times are longer than C, but you run the compiler LESS because it catches bugs earlier.</li>
                        <li>The type system IS the documentation. When you see a function signature, you understand constraints without reading docs.</li>
                    </ul>
                </aside>
            </section>

            <!-- SLIDE 14: Closing - Value for HighQ.aero -->
            <section class="center">
                <h2>Value for HighQ.aero</h2>
                <div style="text-align: left; margin-top: 40px;">
                    <ul>
                        <li><strong>Bring Rust expertise</strong> your team doesn't currently have</li>
                        <li><strong>Reduce debugging time</strong> on safety-critical systems</li>
                        <li><strong>Enable fearless refactoring</strong> as codebase grows</li>
                        <li><strong>Modern tooling</strong> improves developer experience and attracts talent</li>
                        <li><strong>Fluent in C++</strong> — can work in existing codebase (demonstrated by port)</li>
                    </ul>
                </div>
                <div style="margin-top: 60px; padding: 30px; background: #1a1a1a; border-left: 4px solid #5cb85c;">
                    <p class="highlight" style="font-size: 1.2em; margin: 0;">Rust isn't a replacement for C++—it's a force multiplier for embedded teams.</p>
                </div>
                <p style="margin-top: 60px; font-size: 1.5em;">Questions?</p>

                <aside class="notes">
                    <h4>Closing (1 minute):</h4>
                    <p><strong>Your pitch:</strong></p>
                    <p>"I'm not here to tell you to rewrite everything in Rust. C++ works, and I can contribute to it. But for NEW development, especially safety-critical components, Rust offers compelling advantages:</p>
                    <ul>
                        <li>Entire categories of bugs caught at compile time</li>
                        <li>Easier to onboard new engineers (the compiler is a teacher)</li>
                        <li>Refactoring is safe (compiler finds all affected code)</li>
                        <li>Growing ecosystem of embedded crates</li>
                    </ul>
                    <p>I bring my Rust expertise. I can prototype in Rust, port to C++ if needed, or introduce Rust incrementally for new modules.</p>
                    <p>This project demonstrates I can work at the hardware level, understand signal processing, write clean architecture, AND communicate technical concepts effectively.</p>
                    <p>I'm ready to contribute to HighQ.aero's mission."</p>
                    <p><strong>Open for questions.</strong></p>
                </aside>
            </section>

            <!-- SLIDE 15: Backup - Common Questions -->
            <section>
                <h2>Common Questions</h2>
                <ul class="small">
                    <li><strong>Isn't Rust's learning curve too steep?</strong>
                        <ul class="small">
                            <li>Yes, initially. But compiler guides you. Once you understand ownership, it clicks.</li>
                            <li>For experienced embedded engineers, the concepts aren't new (you already think about ownership)</li>
                        </ul>
                    </li>
                    <li><strong>What about real-time constraints?</strong>
                        <ul class="small">
                            <li>Rust is deterministic. No GC, no hidden allocations. Fully predictable timing.</li>
                            <li>RTIC framework provides interrupt-safe concurrency primitives</li>
                        </ul>
                    </li>
                    <li><strong>Certification for safety-critical systems?</strong>
                        <ul class="small">
                            <li>Ferrocene: ISO 26262 / IEC 61508 qualified Rust compiler</li>
                            <li>Used in aerospace (e.g., ESA, Airbus considering Rust)</li>
                        </ul>
                    </li>
                    <li><strong>Interop with existing C/C++?</strong>
                        <ul class="small">
                            <li>Excellent FFI. Can call C from Rust and vice versa with zero overhead</li>
                            <li>Incremental adoption: start with new modules, keep existing code</li>
                        </ul>
                    </li>
                    <li><strong>Toolchain maturity?</strong>
                        <ul class="small">
                            <li>Stable. Rust 1.0 was 2015. Embedded working group since 2018.</li>
                            <li>Used in production: Google (Android), Microsoft (Azure), Meta, Amazon (Firecracker)</li>
                        </ul>
                    </li>
                </ul>

                <aside class="notes">
                    <h4>Backup Slide - Be Ready for These:</h4>
                    <p><strong>Learning curve:</strong> "Yes, Rust has a reputation for being hard to learn. But that's because it's teaching you to think about things C++ lets you ignore. For embedded engineers who already think about ownership, lifetimes, and resource management, Rust formalizes what you're already doing. The compiler becomes your pair programmer."</p>
                    <p><strong>Real-time:</strong> "Rust is fully deterministic. There's no garbage collector, no hidden allocations (in no_std), no dynamic dispatch unless you opt in. You can statically analyze WCET (worst-case execution time) just like C. The RTIC framework (Real-Time Interrupt-driven Concurrency) provides zero-cost interrupt handling with compile-time priority checks."</p>
                    <p><strong>Certification:</strong> "This is the million-dollar question for aerospace. Ferrocene is a commercially supported Rust compiler qualified for ISO 26262 (automotive) and IEC 61508 (industrial). AdaCore is behind it. ESA (European Space Agency) is funding Rust for space applications. It's coming."</p>
                    <p><strong>C/C++ interop:</strong> "Rust has excellent FFI. You can link Rust and C code with zero overhead. The extern 'C' ABI is stable. This means you can introduce Rust incrementally—new modules in Rust, existing code in C++, they call each other seamlessly."</p>
                    <p><strong>Maturity:</strong> "Rust is in production at the biggest tech companies. Google is rewriting parts of Android in Rust. Microsoft uses it in Windows kernel. Linux kernel accepted Rust in 6.1. It's not experimental anymore."</p>
                </aside>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            showNotes: false,  // Speaker notes via speaker view (press 'S')
            plugins: [ RevealNotes, RevealHighlight ],
            transition: 'slide',
            backgroundTransition: 'fade',
            width: 1280,
            height: 720,
            margin: 0.04,
        });
    </script>
</body>
</html>
